<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>x402Resolve - Multi-Oracle Quality Assessment [v1.2]</title>
    <script src="https://cdn.jsdelivr.net/npm/@solana/web3.js@latest/lib/index.iife.min.js?v=1.1"></script>
    <script src="https://cdn.jsdelivr.net/npm/tweetnacl@1.0.3/nacl-fast.min.js?v=1.1"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #000;
            color: #fff;
            font-family: 'Monaco', 'Menlo', monospace;
            padding: 20px;
            max-width: 1000px;
            margin: 0 auto;
        }
        h1 {
            background: linear-gradient(90deg, #00ffff, #ff00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 20px;
            font-size: 28px;
        }
        .section {
            background: #1a1a1a;
            border: 1px solid #333;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 8px;
        }
        button {
            background: linear-gradient(90deg, #00ffff, #ff00ff);
            color: #000;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            margin: 5px 0;
            font-size: 14px;
        }
        button:hover { opacity: 0.8; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        input {
            background: #0a0a0a;
            border: 1px solid #333;
            color: #fff;
            padding: 10px;
            margin: 5px 0;
            border-radius: 4px;
            width: 100%;
            max-width: 200px;
        }
        .status {
            background: #0a0a0a;
            padding: 12px;
            margin: 10px 0;
            border-left: 3px solid #00ffff;
            font-size: 13px;
            border-radius: 4px;
        }
        .success { border-left-color: #10b981; }
        .error { border-left-color: #ef4444; }
        .info { border-left-color: #00ffff; }
        .config-input {
            width: 100%;
            max-width: 600px;
        }
        .progress-container {
            display: none;
            margin: 15px 0;
        }
        .progress-bar {
            background: #0a0a0a;
            border: 1px solid #333;
            border-radius: 4px;
            overflow: hidden;
            height: 8px;
        }
        .progress-fill {
            background: linear-gradient(90deg, #00ffff, #ff00ff);
            height: 100%;
            width: 0%;
            transition: width 0.3s ease;
        }
        .results-box {
            display: none;
            margin-top: 20px;
            padding: 20px;
            background: #0a0a0a;
            border: 2px solid #00ffff;
            border-radius: 8px;
        }
        .results-box h4 {
            color: #00ffff;
            margin-bottom: 15px;
            font-size: 16px;
        }
        .oracle-badge {
            display: inline-block;
            padding: 4px 8px;
            background: #00ffff22;
            border: 1px solid #00ffff;
            border-radius: 4px;
            margin: 2px;
            font-size: 11px;
        }
    </style>
</head>
<body>
    <h1>üîÆ x402Resolve - Multi-Oracle Quality Assessment</h1>
    <div id="modeIndicator" style="background: #ff00ff22; border: 1px solid #ff00ff; padding: 8px; border-radius: 4px; margin-bottom: 15px; font-size: 13px; display: none;">
        ‚ö° <strong>SIMULATION MODE</strong> - Testing UI without blockchain transactions
    </div>

    <div class="section">
        <h2>‚öôÔ∏è Configuration</h2>
        <label>RPC URL:</label><br>
        <input id="rpcUrl" class="config-input" type="text" value="https://api.devnet.solana.com" placeholder="RPC URL">
        <br><br>
        <label>Program ID:</label><br>
        <input id="programId" class="config-input" type="text" value="4x8i1j1Xy9wTPCLELtXuBt6nMwCmfzF9BK47BG8MWWf7" placeholder="Program ID">
        <br><br>
        <label>
            <input type="checkbox" id="simulationMode" checked onchange="updateModeIndicator()">
            <strong>Simulation Mode</strong> (test UI without on-chain transactions)
        </label>
        <br><small style="color: #888;">Uncheck to use real on-chain transactions</small>
        <br><br>
        <button onclick="connect()">Connect to RPC</button>
        <div id="configStatus" class="status info">Enter RPC URL and click Connect</div>
    </div>

    <div class="section">
        <h2>üëõ Wallet Connection</h2>
        <button onclick="connectWallet()">Connect Phantom Wallet</button>
        <div id="walletStatus" class="status info">Click Connect to link your Phantom wallet</div>
    </div>

    <div class="section">
        <h2>üéØ On-Chain Quality Assessment</h2>
        <p style="color: #888; font-size: 12px; margin-bottom: 15px;">
            Complete flow with multi-oracle consensus, reputation tracking, and automated refunds
        </p>

        <label>Escrow Amount (SOL):</label><br>
        <input id="escrowAmount" type="text" value="0.01" placeholder="0.01">
        <br><br>

        <button id="assessmentBtn" onclick="runQualityAssessment()" style="font-size: 16px; padding: 14px 28px;">
            üöÄ Run on-chain quality assessment
        </button>

        <div id="progressContainer" class="progress-container">
            <div class="progress-bar">
                <div id="progressFill" class="progress-fill"></div>
            </div>
        </div>

        <div id="txStatus" class="status info">Connect wallet and click the button to start</div>

        <div id="qualityResults" class="results-box">
            <h4>üìä Quality Assessment Results</h4>
            <div id="oracleConsensus" style="margin-bottom: 15px;"></div>
            <div id="qualityScore" style="margin-bottom: 10px; font-size: 14px;"></div>
            <div id="refundDetails" style="font-size: 13px; color: #ccc;"></div>
        </div>
    </div>

    <div class="section">
        <h2>üìú Transaction Details</h2>
        <div id="results" class="status info">
            <pre id="resultsData" style="color: #888;">Transaction details will appear here...</pre>
        </div>
    </div>

    <script>
        // =================================================================
        // BROWSER-COMPATIBLE BUFFER POLYFILL
        // =================================================================
        class BufferPolyfill {
            static from(data, encoding) {
                let arr;
                if (Array.isArray(data)) {
                    arr = new Uint8Array(data);
                } else if (typeof data === 'string') {
                    const encoder = new TextEncoder();
                    arr = encoder.encode(data);
                } else {
                    arr = new Uint8Array(data);
                }
                arr.copy = function(target, targetStart, sourceStart, sourceEnd) {
                    const start = sourceStart || 0;
                    const end = sourceEnd || this.length;
                    target.set(this.slice(start, end), targetStart);
                };
                return arr;
            }

            static alloc(size) {
                const arr = new Uint8Array(size);
                arr.writeBigUInt64LE = function(value, offset) {
                    const view = new DataView(this.buffer);
                    view.setBigUint64(offset, value, true);
                };
                arr.writeUInt32LE = function(value, offset) {
                    const view = new DataView(this.buffer);
                    view.setUint32(offset, value, true);
                };
                arr.writeUInt8 = function(value, offset) {
                    this[offset] = value;
                };
                arr.copy = function(target, targetStart, sourceStart, sourceEnd) {
                    const start = sourceStart || 0;
                    const end = sourceEnd || this.length;
                    target.set(this.slice(start, end), targetStart);
                };
                return arr;
            }
        }
        const Buffer = BufferPolyfill;

        // =================================================================
        // GLOBAL STATE
        // =================================================================
        let connection;
        let programIdPubkey;
        let wallet = null;
        let walletPublicKey = null;

        // =================================================================
        // MULTI-ORACLE SETUP (3 oracles for consensus)
        // =================================================================
        const oracles = [];
        for (let i = 0; i < 3; i++) {
            const seed = new Uint8Array(32);
            for (let j = 0; j < 32; j++) {
                seed[j] = (i * 50) + j + 100;
            }
            const keypair = nacl.sign.keyPair.fromSeed(seed);
            const publicKey = new solanaWeb3.PublicKey(keypair.publicKey);
            oracles.push({
                name: `Oracle ${i + 1}`,
                keypair: keypair,
                publicKey: publicKey,
                secretKey: keypair.secretKey
            });
            console.log(`${oracles[i].name} Public Key:`, publicKey.toBase58());
        }

        // =================================================================
        // HELPER FUNCTIONS
        // =================================================================

        // Derive PDA with seeds
        function derivePDA(seeds, programId) {
            return solanaWeb3.PublicKey.findProgramAddressSync(seeds, programId);
        }

        // Get quality tier description
        function getQualityTier(score) {
            if (score < 50) return '‚ùå Poor Quality';
            if (score < 65) return '‚ö†Ô∏è Fair Quality';
            if (score < 80) return '‚úÖ Good Quality';
            return 'üéØ Excellent Quality';
        }

        // Calculate refund percentage based on quality
        function calculateRefundPercentage(qualityScore) {
            if (qualityScore < 50) return 100;
            if (qualityScore < 65) return 75;
            if (qualityScore < 80) return 35;
            return 0;
        }

        // Update status display
        function updateTxStatus(message, className) {
            const statusEl = document.getElementById('txStatus');
            statusEl.innerHTML = message;
            statusEl.className = 'status ' + (className || 'info');
        }

        // Update progress bar
        function updateProgress(percent) {
            document.getElementById('progressContainer').style.display = 'block';
            document.getElementById('progressFill').style.width = percent + '%';
        }

        // =================================================================
        // MULTI-ORACLE QUALITY ASSESSMENT
        // =================================================================
        async function generateMultiOracleAssessment(transactionId) {
            const submissions = [];

            for (let i = 0; i < oracles.length; i++) {
                const oracle = oracles[i];

                // Each oracle generates its own quality score (with slight variation)
                const baseScore = 70;
                const variation = Math.floor(Math.random() * 10) - 5; // -5 to +5
                const qualityScore = Math.max(0, Math.min(100, baseScore + variation));

                // Create message and sign it
                const message = `${transactionId}:${qualityScore}`;
                const messageBytes = new TextEncoder().encode(message);
                const signature = nacl.sign.detached(messageBytes, oracle.secretKey);

                submissions.push({
                    oracle: oracle.publicKey,
                    quality_score: qualityScore,
                    signature: Array.from(signature),
                    message: message
                });
            }

            // Calculate consensus (median)
            const scores = submissions.map(s => s.quality_score).sort((a, b) => a - b);
            const consensusScore = scores[Math.floor(scores.length / 2)];
            const refundPercentage = calculateRefundPercentage(consensusScore);

            return {
                submissions,
                consensusScore,
                refundPercentage,
                scores
            };
        }

        // =================================================================
        // CREATE ED25519 VERIFICATION INSTRUCTIONS
        // =================================================================
        function createEd25519Instructions(submissions) {
            const instructions = [];

            for (const submission of submissions) {
                const signatureBytes = new Uint8Array(submission.signature);
                const publicKeyBytes = submission.oracle.toBytes();
                const messageBytes = new TextEncoder().encode(submission.message);

                // Ed25519 instruction data format
                const headerSize = 16;
                const totalSize = headerSize + 64 + 32 + messageBytes.length;
                const dataLayout = new Uint8Array(totalSize);

                let offset = 0;
                dataLayout[offset++] = 1; // num_signatures
                dataLayout[offset++] = 0; // padding

                // signature_offset (u16 LE)
                const sigOffset = headerSize;
                dataLayout[offset++] = sigOffset & 0xFF;
                dataLayout[offset++] = (sigOffset >> 8) & 0xFF;

                // signature_instruction_index (u16 LE) - 0xFFFF = current
                dataLayout[offset++] = 0xFF;
                dataLayout[offset++] = 0xFF;

                // public_key_offset (u16 LE)
                const pubkeyOffset = sigOffset + 64;
                dataLayout[offset++] = pubkeyOffset & 0xFF;
                dataLayout[offset++] = (pubkeyOffset >> 8) & 0xFF;

                // public_key_instruction_index (u16 LE)
                dataLayout[offset++] = 0xFF;
                dataLayout[offset++] = 0xFF;

                // message_data_offset (u16 LE)
                const messageOffset = pubkeyOffset + 32;
                dataLayout[offset++] = messageOffset & 0xFF;
                dataLayout[offset++] = (messageOffset >> 8) & 0xFF;

                // message_data_size (u16 LE)
                dataLayout[offset++] = messageBytes.length & 0xFF;
                dataLayout[offset++] = (messageBytes.length >> 8) & 0xFF;

                // message_instruction_index (u16 LE)
                dataLayout[offset++] = 0xFF;
                dataLayout[offset++] = 0xFF;

                // Copy data
                dataLayout.set(signatureBytes, sigOffset);
                dataLayout.set(publicKeyBytes, pubkeyOffset);
                dataLayout.set(messageBytes, messageOffset);

                instructions.push(new solanaWeb3.TransactionInstruction({
                    keys: [],
                    programId: solanaWeb3.Ed25519Program.programId,
                    data: Buffer.from(dataLayout)
                }));
            }

            return instructions;
        }

        // =================================================================
        // SIMULATION MODE (UI TESTING WITHOUT ON-CHAIN TRANSACTIONS)
        // =================================================================
        async function runSimulatedAssessment() {
            const value = parseFloat(document.getElementById('escrowAmount').value) || 0.01;
            const transactionId = `sim_tx_${Date.now()}_${Math.random().toString(36).substring(2, 15)}`;

            try {
                // Simulate multi-oracle assessment
                updateTxStatus('‚ö° Simulation Mode: Generating multi-oracle consensus...', 'info');
                updateProgress(20);
                await new Promise(resolve => setTimeout(resolve, 1000));

                const assessment = await generateMultiOracleAssessment(transactionId);
                updateProgress(60);
                await new Promise(resolve => setTimeout(resolve, 800));

                updateProgress(100);
                updateTxStatus('‚úÖ Simulation complete! (No blockchain transaction)', 'success');

                // Show oracle consensus
                const oracleConsensusHTML = assessment.submissions.map((s, i) =>
                    `<span class="oracle-badge">${oracles[i].name}: ${s.quality_score}</span>`
                ).join(' ');
                document.getElementById('oracleConsensus').innerHTML = `
                    <strong>Oracle Scores:</strong><br>
                    ${oracleConsensusHTML}<br>
                    <strong style="color: #00ffff;">Consensus (Median): ${assessment.consensusScore}</strong>
                `;

                // Show quality score
                document.getElementById('qualityScore').innerHTML = `
                    <strong>Quality Score:</strong> ${assessment.consensusScore}/100<br>
                    <strong>Assessment:</strong> ${getQualityTier(assessment.consensusScore)}
                `;

                // Show refund details
                const refundAmount = (value * assessment.refundPercentage / 100).toFixed(4);
                const providerAmount = (value * (100 - assessment.refundPercentage) / 100).toFixed(4);
                document.getElementById('refundDetails').innerHTML = `
                    <strong>Refund to Agent:</strong> ${assessment.refundPercentage}% (${refundAmount} SOL)<br>
                    <strong>Payment to Provider:</strong> ${100 - assessment.refundPercentage}% (${providerAmount} SOL)<br>
                    <strong style="color: #ff00ff;">‚ö° SIMULATION MODE - No real transaction</strong>
                `;

                document.getElementById('qualityResults').style.display = 'block';

                // Update results section
                document.getElementById('resultsData').textContent = JSON.stringify({
                    mode: 'SIMULATION',
                    transaction_id: transactionId,
                    agent: walletPublicKey.toBase58(),
                    amount: value + ' SOL',
                    oracle_scores: assessment.scores,
                    consensus_score: assessment.consensusScore,
                    refund_percentage: assessment.refundPercentage + '%',
                    note: 'This is a simulated run - no blockchain transaction was created'
                }, null, 2);

            } catch (error) {
                updateTxStatus(`‚ùå Simulation error: ${error.message}`, 'error');
                console.error('Simulation error:', error);
            }
        }

        // =================================================================
        // MAIN FLOW: RUN QUALITY ASSESSMENT
        // =================================================================
        async function runQualityAssessment() {
            const btn = document.getElementById('assessmentBtn');
            const simulationMode = document.getElementById('simulationMode').checked;

            if (!wallet || !walletPublicKey) {
                updateTxStatus('‚ùå Please connect wallet first', 'error');
                return;
            }
            if (!connection && !simulationMode) {
                updateTxStatus('‚ùå Please connect to RPC first', 'error');
                return;
            }

            btn.disabled = true;
            document.getElementById('qualityResults').style.display = 'none';
            updateProgress(0);

            if (simulationMode) {
                await runSimulatedAssessment();
                btn.disabled = false;
                return;
            }

            const value = parseFloat(document.getElementById('escrowAmount').value);
            if (!value || value <= 0) {
                updateTxStatus('‚ùå Please enter a valid amount', 'error');
                btn.disabled = false;
                return;
            }

            const transactionId = `tx_${Date.now()}_${Math.random().toString(36).substring(2, 15)}`;
            const apiPublicKey = oracles[0].publicKey; // Using first oracle as API for demo

            try {
                // Verify program exists
                updateTxStatus('Verifying program deployment...', '');
                const programInfo = await connection.getAccountInfo(programIdPubkey);
                if (!programInfo) {
                    updateTxStatus(`‚ùå Program not found on this network. Deploy program ID ${programIdPubkey.toBase58()} first.`, 'error');
                    btn.disabled = false;
                    return;
                }
                if (!programInfo.executable) {
                    updateTxStatus(`‚ùå Program account is not executable`, 'error');
                    btn.disabled = false;
                    return;
                }
                console.log('‚úÖ Program verified:', programIdPubkey.toBase58());

                // ============================================================
                // STEP 1: Initialize Oracle Registry (if needed)
                // ============================================================
                updateTxStatus('Step 1/5: Checking oracle registry...', '');
                updateProgress(10);

                const [registryPDA] = derivePDA([Buffer.from('oracle_registry')], programIdPubkey);
                const registryInfo = await connection.getAccountInfo(registryPDA);

                if (!registryInfo) {
                    updateTxStatus('Step 1/5: Initializing oracle registry...', '');

                    const discriminator = Buffer.from([190, 92, 228, 114, 56, 71, 101, 220]);
                    const dataLayout = Buffer.alloc(10);
                    discriminator.copy(dataLayout, 0);
                    dataLayout.writeUInt8(2, 8); // min_consensus
                    dataLayout.writeUInt8(15, 9); // max_deviation

                    const registryTx = new solanaWeb3.Transaction().add(
                        new solanaWeb3.TransactionInstruction({
                            programId: programIdPubkey,
                            keys: [
                                { pubkey: registryPDA, isSigner: false, isWritable: true },
                                { pubkey: walletPublicKey, isSigner: true, isWritable: true },
                                { pubkey: solanaWeb3.SystemProgram.programId, isSigner: false, isWritable: false },
                            ],
                            data: dataLayout
                        })
                    );

                    registryTx.feePayer = walletPublicKey;
                    const { blockhash } = await connection.getLatestBlockhash('confirmed');
                    registryTx.recentBlockhash = blockhash;

                    const signed = await wallet.signAndSendTransaction(registryTx);
                    await connection.confirmTransaction(signed.signature, 'confirmed');

                    updateTxStatus('‚úÖ Registry initialized', 'success');
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }

                // ============================================================
                // STEP 2: Initialize Reputation Accounts
                // ============================================================
                updateTxStatus('Step 2/5: Initializing reputation accounts...', '');
                updateProgress(25);

                const [agentReputation] = derivePDA([Buffer.from('reputation'), walletPublicKey.toBuffer()], programIdPubkey);
                const [apiReputation] = derivePDA([Buffer.from('reputation'), apiPublicKey.toBuffer()], programIdPubkey);

                const discriminatorReputation = Buffer.from([236, 239, 233, 112, 220, 149, 26, 175]);

                const reputationTx = new solanaWeb3.Transaction();

                // Check and add agent reputation
                const agentRepInfo = await connection.getAccountInfo(agentReputation);
                if (!agentRepInfo) {
                    reputationTx.add(new solanaWeb3.TransactionInstruction({
                        programId: programIdPubkey,
                        keys: [
                            { pubkey: agentReputation, isSigner: false, isWritable: true },
                            { pubkey: walletPublicKey, isSigner: false, isWritable: false },
                            { pubkey: walletPublicKey, isSigner: true, isWritable: true },
                            { pubkey: solanaWeb3.SystemProgram.programId, isSigner: false, isWritable: false },
                        ],
                        data: discriminatorReputation
                    }));
                }

                // Check and add API reputation
                const apiRepInfo = await connection.getAccountInfo(apiReputation);
                if (!apiRepInfo) {
                    reputationTx.add(new solanaWeb3.TransactionInstruction({
                        programId: programIdPubkey,
                        keys: [
                            { pubkey: apiReputation, isSigner: false, isWritable: true },
                            { pubkey: apiPublicKey, isSigner: false, isWritable: false },
                            { pubkey: walletPublicKey, isSigner: true, isWritable: true },
                            { pubkey: solanaWeb3.SystemProgram.programId, isSigner: false, isWritable: false },
                        ],
                        data: discriminatorReputation
                    }));
                }

                if (reputationTx.instructions.length > 0) {
                    reputationTx.feePayer = walletPublicKey;
                    const { blockhash } = await connection.getLatestBlockhash('confirmed');
                    reputationTx.recentBlockhash = blockhash;

                    const signed = await wallet.signAndSendTransaction(reputationTx);
                    await connection.confirmTransaction(signed.signature, 'confirmed');
                }

                // ============================================================
                // STEP 3: Create Escrow
                // ============================================================
                updateTxStatus('Step 3/5: Creating escrow...', '');
                updateProgress(50);

                const [escrowPDA] = derivePDA([Buffer.from('escrow'), Buffer.from(transactionId)], programIdPubkey);

                const discriminatorEscrow = Buffer.from([243, 160, 77, 153, 11, 92, 48, 209]);
                const escrowData = Buffer.alloc(1000);
                let offset = 0;

                discriminatorEscrow.copy(escrowData, offset);
                offset += 8;

                const amountLamports = Math.floor(value * solanaWeb3.LAMPORTS_PER_SOL);
                escrowData.writeBigUInt64LE(BigInt(amountLamports), offset);
                offset += 8;

                const timeLock = 86400; // 24 hours
                escrowData.writeBigUInt64LE(BigInt(timeLock), offset);
                offset += 8;

                const txIdBytes = Buffer.from(transactionId, 'utf-8');
                escrowData.writeUInt32LE(txIdBytes.length, offset);
                offset += 4;
                txIdBytes.copy(escrowData, offset);
                offset += txIdBytes.length;

                escrowData.writeUInt8(0, offset); // is_spl_token = false
                offset += 1;

                const escrowTx = new solanaWeb3.Transaction().add(
                    new solanaWeb3.TransactionInstruction({
                        programId: programIdPubkey,
                        keys: [
                            { pubkey: escrowPDA, isSigner: false, isWritable: true },
                            { pubkey: walletPublicKey, isSigner: true, isWritable: true },
                            { pubkey: apiPublicKey, isSigner: false, isWritable: false },
                            { pubkey: solanaWeb3.SystemProgram.programId, isSigner: false, isWritable: false },
                            { pubkey: solanaWeb3.SystemProgram.programId, isSigner: false, isWritable: false }, // token_mint (unused)
                            { pubkey: escrowPDA, isSigner: false, isWritable: true }, // escrow_token_account (unused)
                            { pubkey: walletPublicKey, isSigner: false, isWritable: true }, // agent_token_account (unused)
                            { pubkey: new solanaWeb3.PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'), isSigner: false, isWritable: false },
                            { pubkey: new solanaWeb3.PublicKey('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'), isSigner: false, isWritable: false },
                        ],
                        data: escrowData.slice(0, offset)
                    })
                );

                escrowTx.feePayer = walletPublicKey;
                let blockhash = (await connection.getLatestBlockhash('confirmed')).blockhash;
                escrowTx.recentBlockhash = blockhash;

                const escrowSigned = await wallet.signAndSendTransaction(escrowTx);
                await connection.confirmTransaction(escrowSigned.signature, 'confirmed');

                // ============================================================
                // STEP 4: Generate Multi-Oracle Quality Assessment
                // ============================================================
                updateTxStatus('Step 4/5: Generating multi-oracle consensus...', '');
                updateProgress(70);

                const assessment = await generateMultiOracleAssessment(transactionId);

                // ============================================================
                // STEP 5: Resolve Dispute with Multi-Oracle
                // ============================================================
                updateTxStatus('Step 5/5: Resolving dispute on-chain...', '');
                updateProgress(85);

                // Build resolve_dispute_multi_oracle instruction
                const discriminatorResolve = Buffer.from([30, 194, 15, 52, 59, 167, 234, 143]);

                // Encode submissions array
                const submissionsData = Buffer.alloc(4 + (assessment.submissions.length * (32 + 1 + 64)));
                offset = 0;

                // Vector length
                submissionsData.writeUInt32LE(assessment.submissions.length, offset);
                offset += 4;

                // Each submission
                for (const sub of assessment.submissions) {
                    // Oracle pubkey (32 bytes)
                    sub.oracle.toBuffer().copy(submissionsData, offset);
                    offset += 32;

                    // Quality score (1 byte)
                    submissionsData.writeUInt8(sub.quality_score, offset);
                    offset += 1;

                    // Signature (64 bytes)
                    Buffer.from(sub.signature).copy(submissionsData, offset);
                    offset += 64;
                }

                const resolveData = Buffer.alloc(discriminatorResolve.length + offset);
                discriminatorResolve.copy(resolveData, 0);
                submissionsData.copy(resolveData, discriminatorResolve.length);

                // Create Ed25519 verification instructions (one per oracle)
                const ed25519Instructions = createEd25519Instructions(assessment.submissions);

                // Build resolve transaction
                const resolveTx = new solanaWeb3.Transaction();

                // Add Ed25519 verifications first
                ed25519Instructions.forEach(ix => resolveTx.add(ix));

                // Add resolve instruction
                resolveTx.add(new solanaWeb3.TransactionInstruction({
                    programId: programIdPubkey,
                    keys: [
                        { pubkey: escrowPDA, isSigner: false, isWritable: true },
                        { pubkey: registryPDA, isSigner: false, isWritable: false },
                        { pubkey: walletPublicKey, isSigner: false, isWritable: true },
                        { pubkey: apiPublicKey, isSigner: false, isWritable: true },
                        { pubkey: agentReputation, isSigner: false, isWritable: true },
                        { pubkey: apiReputation, isSigner: false, isWritable: true },
                        { pubkey: solanaWeb3.SYSVAR_INSTRUCTIONS_PUBKEY, isSigner: false, isWritable: false },
                        { pubkey: solanaWeb3.SystemProgram.programId, isSigner: false, isWritable: false },
                    ],
                    data: resolveData
                }));

                resolveTx.feePayer = walletPublicKey;
                blockhash = (await connection.getLatestBlockhash('confirmed')).blockhash;
                resolveTx.recentBlockhash = blockhash;

                const resolveSigned = await wallet.signAndSendTransaction(resolveTx);
                await connection.confirmTransaction(resolveSigned.signature, 'confirmed');

                updateProgress(100);

                // ============================================================
                // SHOW RESULTS
                // ============================================================
                updateTxStatus('‚úÖ Quality assessment complete!', 'success');

                // Show oracle consensus
                const oracleConsensusHTML = assessment.submissions.map((s, i) =>
                    `<span class="oracle-badge">${oracles[i].name}: ${s.quality_score}</span>`
                ).join(' ');
                document.getElementById('oracleConsensus').innerHTML = `
                    <strong>Oracle Scores:</strong><br>
                    ${oracleConsensusHTML}<br>
                    <strong style="color: #00ffff;">Consensus (Median): ${assessment.consensusScore}</strong>
                `;

                // Show quality score
                document.getElementById('qualityScore').innerHTML = `
                    <strong>Quality Score:</strong> ${assessment.consensusScore}/100<br>
                    <strong>Assessment:</strong> ${getQualityTier(assessment.consensusScore)}
                `;

                // Show refund details
                const refundAmount = (value * assessment.refundPercentage / 100).toFixed(4);
                const providerAmount = (value * (100 - assessment.refundPercentage) / 100).toFixed(4);
                document.getElementById('refundDetails').innerHTML = `
                    <strong>Refund to Agent:</strong> ${assessment.refundPercentage}% (${refundAmount} SOL)<br>
                    <strong>Payment to Provider:</strong> ${100 - assessment.refundPercentage}% (${providerAmount} SOL)<br>
                    <strong>Transaction:</strong> <a href="https://explorer.solana.com/tx/${resolveSigned.signature}?cluster=custom" target="_blank" style="color: #00ffff;">${resolveSigned.signature.substring(0, 20)}...</a>
                `;

                document.getElementById('qualityResults').style.display = 'block';

                // Update results section
                document.getElementById('resultsData').textContent = JSON.stringify({
                    transaction_id: transactionId,
                    escrow_pda: escrowPDA.toBase58(),
                    agent: walletPublicKey.toBase58(),
                    provider: apiPublicKey.toBase58(),
                    amount: value + ' SOL',
                    oracle_scores: assessment.scores,
                    consensus_score: assessment.consensusScore,
                    refund_percentage: assessment.refundPercentage + '%',
                    signatures: {
                        escrow: escrowSigned.signature,
                        resolve: resolveSigned.signature
                    }
                }, null, 2);

            } catch (error) {
                console.error('Quality assessment error details:', {
                    error: error,
                    message: error.message,
                    stack: error.stack,
                    logs: error.logs || 'No logs available'
                });

                let errorMsg = error.message || 'Unknown error';
                if (error.logs) {
                    console.error('Transaction logs:', error.logs);
                    errorMsg += '<br><small>Check console for detailed logs</small>';
                }

                updateTxStatus(`‚ùå Assessment failed: ${errorMsg}`, 'error');
            } finally {
                btn.disabled = false;
            }
        }

        // =================================================================
        // WALLET CONNECTION
        // =================================================================
        async function connectWallet() {
            try {
                if (!window.solana || !window.solana.isPhantom) {
                    updateWalletStatus('‚ùå Phantom wallet not detected<br><br>Please install from <a href="https://phantom.app" target="_blank" style="color: #00ffff;">phantom.app</a>', 'error');
                    return;
                }

                document.getElementById('walletStatus').innerHTML = 'üîÑ Connecting to Phantom...';

                const response = await window.solana.connect();
                wallet = window.solana;
                walletPublicKey = response.publicKey;

                let balance = 0;
                if (connection) {
                    try {
                        balance = await connection.getBalance(walletPublicKey);
                    } catch (err) {
                        console.warn('Could not fetch balance:', err);
                    }
                }

                document.getElementById('walletStatus').innerHTML = `
                    ‚úÖ Connected to Phantom<br>
                    <strong>Wallet:</strong> ${walletPublicKey.toBase58()}<br>
                    <strong>Balance:</strong> ${(balance / 1e9).toFixed(4)} SOL
                `;
                document.getElementById('walletStatus').className = 'status success';

            } catch (error) {
                document.getElementById('walletStatus').innerHTML = `‚ùå Connection failed: ${error.message}`;
                document.getElementById('walletStatus').className = 'status error';
            }
        }

        // =================================================================
        // RPC CONNECTION
        // =================================================================
        async function connect() {
            const rpcUrl = document.getElementById('rpcUrl').value;
            const programIdStr = document.getElementById('programId').value;

            updateTxStatus('üîÑ Connecting...', '');

            try {
                connection = new solanaWeb3.Connection(rpcUrl, 'confirmed');
                programIdPubkey = new solanaWeb3.PublicKey(programIdStr);

                const version = await connection.getVersion();

                document.getElementById('configStatus').innerHTML = `‚úÖ Connected! Solana version: ${JSON.stringify(version)}`;
                document.getElementById('configStatus').className = 'status success';

            } catch (error) {
                document.getElementById('configStatus').innerHTML = `‚ùå Connection failed: ${error.message}`;
                document.getElementById('configStatus').className = 'status error';
            }
        }

        console.log('üîÆ x402Resolve Multi-Oracle Demo Ready [v1.2]');
        console.log('Multi-oracle setup:', oracles.length, 'oracles configured');
        console.log('Cache cleared - Fresh version loaded:', new Date().toISOString());
        console.log('Features: Simulation mode for UI testing, Enhanced error logging');

        // Mode indicator
        function updateModeIndicator() {
            const simulationMode = document.getElementById('simulationMode').checked;
            const indicator = document.getElementById('modeIndicator');
            indicator.style.display = simulationMode ? 'block' : 'none';
        }
        updateModeIndicator();
    </script>
</body>
</html>
